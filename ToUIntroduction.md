# Introduction #

It becomes a problem sometimes when establishing a direct transmission control protocol (TCP) connection between two hosts behind NATs. When both the client and server are behind different NAT devices, the applications running on hosts may not be able to establish a direct TCP connection with one another. However, with certain NAT types, such as applying ICE-UDP [2](2.md), although applications cannot establish TCP connections directly, it is possible for these applications to exchange user datagram protocol (UDP) traffic. In this sense, using UDP is preferable for such applications; nevertheless, applications may require the underlying transport layer to provide reliability, connection control, congestion control, and flow control mechanisms. Unlike TCP, UDP fails to provide these semantics. Therefore, in [1](1.md), the TCP-over-UDP (ToU), a reliable, congestion control, and flow control transport protocol on top of UDP, is proposed, and in order to achieve these mechanisms, ToU almost uses the same header as TCP does which allows ToU to easily implement TCP's reliability, connection control mechanism, congestion control mechanism  and congestion control mechanism.
In this project, we have implemented an efficient socket-like library in C/C++ for programmers to use. In order to make ToU library simple and easy, the APIs of ToU is just like C/C++ socket APIs [3](3.md). We will describe briefly the APIs of ToU in Section 4.1.1. The implementation of ToU is in accordance with the draft of [1](1.md) and the algorithms described in RFC documents related to TCP specifications such as [4](4.md), [5](5.md), [6](6.md), [7](7.md), [8](8.md), and [9](9.md). We will discuss details in Section 4.1.2.
ToU library is an user-space library which includes Boost C++ library [3](3.md) for managing threads and timers, and since it is on top of UDP, UDP-related functions such as sendto() and recvfrom() are called to carry out the underlying sending and receiving. We will present the ToU transmission model in Section 4.2.1 and 4.2.2, and will also illustrate program internal operations and what each program does in a form of finite state machine (FSM) in Section 4.2.2.
The rest of the paper is organized as follows. In Section 2 and 3, we will show the related works of ToU and its background, respectively. Section 4 shows the architecture and implementation in detail. In Section 5, we will demonstrate that the patterns of congestion window size, average throughput, and performance of ToU are close to real TCP Reno by giving variant experiments on well-configured real machines. Our analysis and conclusion are also summarized. The task list will be shown in Section 6.